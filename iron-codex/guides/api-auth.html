<!-- Authentication Section (12 Controls) -->
<section id="authentication" class="control-section">
    <h2>1. Authentication (12 Controls)</h2>
    <p class="section-intro">Strong authentication mechanisms are the foundation of API security. These controls establish user identity and ensure only authenticated entities can access your APIs.</p>

    <!-- Control 1.1 -->
    <div class="control-card">
        <div class="control-header">
            <h3 class="control-title">1.1 Multi-Factor Authentication (MFA)</h3>
            <div class="control-badges">
                <span class="badge priority-critical">Critical</span>
                <span class="badge difficulty-medium">Medium</span>
            </div>
        </div>
        
        <div class="control-content">
            <p class="control-description">Implement multi-factor authentication for all API access, especially for privileged operations and sensitive data access.</p>
            
            <div class="implementation">
                <h4>ðŸ”§ Implementation</h4>
                <pre><code>// OAuth 2.0 with PKCE + TOTP Example
const auth = {
    // Step 1: PKCE Challenge
    codeVerifier: generateCodeVerifier(),
    codeChallenge: generateCodeChallenge(codeVerifier),
    
    // Step 2: Request authorization with MFA requirement
    authUrl: `https://auth.example.com/oauth/authorize?` +
             `client_id=${clientId}&` +
             `redirect_uri=${redirectUri}&` +
             `code_challenge=${codeChallenge}&` +
             `code_challenge_method=S256&` +
             `scope=api:read api:write&` +
             `acr_values=mfa`,  // Require MFA
    
    // Step 3: Exchange code for token (includes MFA verification)
    async exchangeToken(authCode) {
        const response = await fetch('/oauth/token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                grant_type: 'authorization_code',
                client_id: clientId,
                code: authCode,
                redirect_uri: redirectUri,
                code_verifier: this.codeVerifier
            })
        });
        return response.json();
    }
};</code></pre>
            </div>

            <div class="validation">
                <h4>âœ… Validation</h4>
                <ul>
                    <li>Verify MFA challenge completion before token issuance</li>
                    <li>Check token includes MFA claim (amr: ["mfa", "totp"])</li>
                    <li>Test MFA bypass attempts return 401 Unauthorized</li>
                    <li>Validate MFA requirement for sensitive operations</li>
                </ul>
            </div>

            <div class="best-practices">
                <h4>ðŸ“‹ Best Practices</h4>
                <ul>
                    <li>Support multiple MFA methods (TOTP, SMS, hardware keys)</li>
                    <li>Implement adaptive MFA based on risk factors</li>
                    <li>Provide MFA recovery mechanisms</li>
                    <li>Monitor and alert on MFA failures</li>
                </ul>
            </div>

            <div class="security-notes">
                <h4>ðŸ”’ Security Notes</h4>
                <ul>
                    <li>SMS-based MFA is vulnerable to SIM swapping</li>
                    <li>Consider WebAuthn/FIDO2 for passwordless MFA</li>
                    <li>Implement rate limiting on MFA attempts</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Control 1.2 -->
    <div class="control-card">
        <div class="control-header">
            <h3 class="control-title">1.2 JWT Token Validation</h3>
            <div class="control-badges">
                <span class="badge priority-critical">Critical</span>
                <span class="badge difficulty-high">High</span>
            </div>
        </div>
        
        <div class="control-content">
            <p class="control-description">Properly validate JSON Web Tokens including signature verification, expiration, and claims validation.</p>
            
            <div class="implementation">
                <h4>ðŸ”§ Implementation</h4>
                <pre><code>const jwt = require('jsonwebtoken');
const jwksClient = require('jwks-rsa');

// JWKS client for key rotation
const client = jwksClient({
    jwksUri: 'https://auth.example.com/.well-known/jwks.json',
    cache: true,
    cacheMaxAge: 86400000, // 24 hours
    rateLimit: true,
    jwksRequestsPerMinute: 5
});

function getKey(header, callback) {
    client.getSigningKey(header.kid, (err, key) => {
        const signingKey = key.publicKey || key.rsaPublicKey;
        callback(null, signingKey);
    });
}

// Middleware for JWT validation
function validateJWT(req, res, next) {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
        return res.status(401).json({ error: 'Missing token' });
    }

    jwt.verify(token, getKey, {
        audience: process.env.JWT_AUDIENCE,
        issuer: process.env.JWT_ISSUER,
        algorithms: ['RS256'],
        clockTolerance: 30, // 30 second clock skew tolerance
        maxAge: '1h' // Maximum token age
    }, (err, decoded) => {
        if (err) {
            return res.status(401).json({ 
                error: 'Invalid token',
                details: err.message 
            });
        }
        
        // Additional custom validations
        if (!decoded.sub || !decoded.scope) {
            return res.status(401).json({ error: 'Invalid token claims' });
        }
        
        req.user = decoded;
        next();
    });
}</code></pre>
            </div>

            <div class="validation">
                <h4>âœ… Validation</h4>
                <ul>
                    <li>Verify signature with correct public key</li>
                    <li>Check token expiration (exp claim)</li>
                    <li>Validate issuer (iss) and audience (aud) claims</li>
                    <li>Ensure algorithm is explicitly whitelisted</li>
                    <li>Test with tampered tokens to ensure rejection</li>
                </ul>
            </div>

            <div class="best-practices">
                <h4>ðŸ“‹ Best Practices</h4>
                <ul>
                    <li>Use short-lived access tokens (15-60 minutes)</li>
                    <li>Implement token refresh mechanisms</li>
                    <li>Include necessary claims only (principle of least privilege)</li>
                    <li>Use secure key rotation practices</li>
                </ul>
            </div>

            <div class="security-notes">
                <h4>ðŸ”’ Security Notes</h4>
                <ul>
                    <li>Never accept "none" algorithm</li>
                    <li>Always validate the "alg" header parameter</li>
                    <li>Beware of key confusion attacks (RSA/HMAC)</li>
                    <li>Implement proper JWKS caching and rotation</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Control 1.3 -->
    <div class="control-card">
        <div class="control-header">
            <h3 class="control-title">1.3 OAuth 2.0 PKCE Implementation</h3>
            <div class="control-badges">
                <span class="badge priority-high">High</span>
                <span class="badge difficulty-medium">Medium</span>
            </div>
        </div>
        
        <div class="control-content">
            <p class="control-description">Implement Proof Key for Code Exchange (PKCE) to secure OAuth 2.0 authorization code flow against code interception attacks.</p>
            
            <div class="implementation">
                <h4>ðŸ”§ Implementation</h4>
                <pre><code>// Client-side PKCE implementation
class PKCEAuth {
    constructor(clientId, redirectUri, authEndpoint, tokenEndpoint) {
        this.clientId = clientId;
        this.redirectUri = redirectUri;
        this.authEndpoint = authEndpoint;
        this.tokenEndpoint = tokenEndpoint;
    }

    // Generate code verifier (43-128 characters)
    generateCodeVerifier() {
        const array = new Uint8Array(32);
        crypto.getRandomValues(array);
        return btoa(String.fromCharCode(...array))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
    }

    // Generate code challenge
    async generateCodeChallenge(verifier) {
        const encoder = new TextEncoder();
        const data = encoder.encode(verifier);
        const digest = await crypto.subtle.digest('SHA-256', data);
        return btoa(String.fromCharCode(...new Uint8Array(digest)))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
    }

    // Start authorization flow
    async startAuth(scopes = ['read']) {
        this.codeVerifier = this.generateCodeVerifier();
        this.codeChallenge = await this.generateCodeChallenge(this.codeVerifier);
        this.state = crypto.randomUUID();

        const params = new URLSearchParams({
            response_type: 'code',
            client_id: this.clientId,
            redirect_uri: this.redirectUri,
            scope: scopes.join(' '),
            state: this.state,
            code_challenge: this.codeChallenge,
            code_challenge_method: 'S256'
        });

        window.location.href = `${this.authEndpoint}?${params}`;
    }

    // Exchange authorization code for tokens
    async exchangeCodeForTokens(code, state) {
        if (state !== this.state) {
            throw new Error('State mismatch - possible CSRF attack');
        }

        const response = await fetch(this.tokenEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                grant_type: 'authorization_code',
                client_id: this.clientId,
                code: code,
                redirect_uri: this.redirectUri,
                code_verifier: this.codeVerifier
            })
        });

        if (!response.ok) {
            throw new Error(`Token exchange failed: ${response.status}`);
        }

        return response.json();
    }
}</code></pre>
            </div>

            <div class="validation">
                <h4>âœ… Validation</h4>
                <ul>
                    <li>Verify code verifier matches code challenge</li>
                    <li>Ensure code challenge method is S256</li>
                    <li>Validate state parameter to prevent CSRF</li>
                    <li>Test with invalid code verifier to ensure rejection</li>
                </ul>
            </div>

            <div class="best-practices">
                <h4>ðŸ“‹ Best Practices</h4>
                <ul>
                    <li>Always use S256 challenge method (not plain)</li>
                    <li>Generate cryptographically secure random values</li>
                    <li>Store code verifier securely on client</li>
                    <li>Implement proper error handling</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Control 1.4 -->
    <div class="control-card">
        <div class="control-header">
            <h3 class="control-title">1.4 API Key Management</h3>
            <div class="control-badges">
                <span class="badge priority-high">High</span>
                <span class="badge difficulty-low">Low</span>
            </div>
        </div>
        
        <div class="control-content">
            <p class="control-description">Implement secure API key generation, distribution, rotation, and revocation mechanisms.</p>
            
            <div class="implementation">
                <h4>ðŸ”§ Implementation</h4>
                <pre><code>// API Key Management System
const crypto = require('crypto');

class APIKeyManager {
    constructor(database) {
        this.db = database;
        this.keyPrefix = 'ak_'; // API key prefix for identification
    }

    // Generate secure API key
    generateAPIKey() {
        const randomBytes = crypto.randomBytes(32);
        const apiKey = this.keyPrefix + randomBytes.toString('base64url');
        return apiKey;
    }

    // Create API key with metadata
    async createAPIKey(userId, scopes, expiresIn = '1y') {
        const apiKey = this.generateAPIKey();
        const hashedKey = crypto.createHash('sha256').update(apiKey).digest('hex');
        
        const keyData = {
            id: crypto.randomUUID(),
            user_id: userId,
            key_hash: hashedKey,
            scopes: scopes,
            created_at: new Date(),
            expires_at: new Date(Date.now() + this.parseExpiry(expiresIn)),
            last_used: null,
            is_active: true
        };

        await this.db.apiKeys.insert(keyData);
        
        // Return the plain key only once
        return {
            id: keyData.id,
            key: apiKey, // Only returned during creation
            scopes: keyData.scopes,
            expires_at: keyData.expires_at
        };
    }

    // Validate API key
    async validateAPIKey(apiKey) {
        if (!apiKey || !apiKey.startsWith(this.keyPrefix)) {
            return null;
        }

        const hashedKey = crypto.createHash('sha256').update(apiKey).digest('hex');
        
        const keyRecord = await this.db.apiKeys.findOne({
            key_hash: hashedKey,
            is_active: true,
            expires_at: { $gt: new Date() }
        });

        if (keyRecord) {
            // Update last used timestamp
            await this.db.apiKeys.updateOne(
                { id: keyRecord.id },
                { $set: { last_used: new Date() } }
            );
        }

        return keyRecord;
    }

    // Rotate API key
    async rotateAPIKey(keyId) {
        const oldKey = await this.db.apiKeys.findOne({ id: keyId });
        if (!oldKey) throw new Error('API key not found');

        const newKey = await this.createAPIKey(
            oldKey.user_id, 
            oldKey.scopes,
            '1y'
        );

        // Mark old key as rotated (keep for audit)
        await this.db.apiKeys.updateOne(
            { id: keyId },
            { 
                $set: { 
                    is_active: false, 
                    rotated_at: new Date(),
                    replaced_by: newKey.id
                }
            }
        );

        return newKey;
    }

    // Middleware for API key authentication
    middleware() {
        return async (req, res, next) => {
            const apiKey = req.headers['x-api-key'] || 
                          req.headers['authorization']?.replace('Bearer ', '');

            if (!apiKey) {
                return res.status(401).json({ error: 'API key required' });
            }

            const keyRecord = await this.validateAPIKey(apiKey);
            
            if (!keyRecord) {
                return res.status(401).json({ error: 'Invalid API key' });
            }

            req.apiKey = keyRecord;
            req.user = { id: keyRecord.user_id };
            next();
        };
    }
}</code></pre>
            </div>

            <div class="validation">
                <h4>âœ… Validation</h4>
                <ul>
                    <li>Test API key validation with valid/invalid keys</li>
                    <li>Verify expired keys are rejected</li>
                    <li>Check revoked keys cannot be used</li>
                    <li>Validate scope-based access control</li>
                </ul>
            </div>

            <div class="best-practices">
                <h4>ðŸ“‹ Best Practices</h4>
                <ul>
                    <li>Use cryptographically secure random generation</li>
                    <li>Store hashed versions, never plaintext</li>
                    <li>Implement key rotation policies</li>
                    <li>Add metadata (creation time, last used, scope)</li>
                    <li>Use prefixes for key identification</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Controls 1.5-1.12 continue with similar structure... -->
    <!-- For brevity, I'll add a few more key controls -->

    <!-- Control 1.5 -->
    <div class="control-card">
        <div class="control-header">
            <h3 class="control-title">1.5 Session Management</h3>
            <div class="control-badges">
                <span class="badge priority-high">High</span>
                <span class="badge difficulty-medium">Medium</span>
            </div>
        </div>
        
        <div class="control-content">
            <p class="control-description">Implement secure session management with proper timeout, invalidation, and concurrent session handling.</p>
            
            <div class="implementation">
                <h4>ðŸ”§ Implementation</h4>
                <pre><code>// Secure Session Manager
class SessionManager {
    constructor(redis, options = {}) {
        this.redis = redis;
        this.sessionTimeout = options.timeout || 3600; // 1 hour
        this.maxConcurrentSessions = options.maxSessions || 5;
        this.sessionPrefix = 'session:';
    }

    async createSession(userId, metadata = {}) {
        const sessionId = crypto.randomBytes(32).toString('hex');
        const sessionKey = this.sessionPrefix + sessionId;
        
        const sessionData = {
            userId,
            createdAt: Date.now(),
            lastActivity: Date.now(),
            ipAddress: metadata.ipAddress,
            userAgent: metadata.userAgent,
            isActive: true
        };

        // Check concurrent session limit
        await this.enforceConcurrentSessionLimit(userId);

        // Store session with TTL
        await this.redis.setex(
            sessionKey, 
            this.sessionTimeout, 
            JSON.stringify(sessionData)
        );

        // Track user sessions
        await this.redis.sadd(`user_sessions:${userId}`, sessionId);

        return sessionId;
    }

    async validateSession(sessionId) {
        const sessionKey = this.sessionPrefix + sessionId;
        const sessionData = await this.redis.get(sessionKey);
        
        if (!sessionData) return null;

        const session = JSON.parse(sessionData);
        
        // Update last activity
        session.lastActivity = Date.now();
        await this.redis.setex(
            sessionKey, 
            this.sessionTimeout, 
            JSON.stringify(session)
        );

        return session;
    }

    async destroySession(sessionId) {
        const sessionKey = this.sessionPrefix + sessionId;
        const sessionData = await this.redis.get(sessionKey);
        
        if (sessionData) {
            const session = JSON.parse(sessionData);
            await this.redis.del(sessionKey);
            await this.redis.srem(`user_sessions:${session.userId}`, sessionId);
        }
    }

    async enforceConcurrentSessionLimit(userId) {
        const userSessionsKey = `user_sessions:${userId}`;
        const sessionIds = await this.redis.smembers(userSessionsKey);
        
        if (sessionIds.length >= this.maxConcurrentSessions) {
            // Remove oldest session
            const oldestSession = sessionIds[0]; // Implement proper LRU if needed
            await this.destroySession(oldestSession);
        }
    }
}</code></pre>
            </div>
        </div>
    </div>

    <!-- Additional controls 1.6-1.12 would continue here with similar detailed structure -->
</section>

<!-- Authorization Section (10 Controls) -->
<section id="authorization" class="control-section">
    <h2>2. Authorization (10 Controls)</h2>
    <p class="section-intro">Authorization controls ensure that authenticated users can only access resources and perform actions they are explicitly permitted to. These controls implement fine-grained access control policies.</p>

    <!-- Control 2.1 -->
    <div class="control-card">
        <div class="control-header">
            <h3 class="control-title">2.1 Role-Based Access Control (RBAC)</h3>
            <div class="control-badges">
                <span class="badge priority-critical">Critical</span>
                <span class="badge difficulty-medium">Medium</span>
            </div>
        </div>
        
        <div class="control-content">
            <p class="control-description">Implement comprehensive role-based access control with hierarchical roles and permission inheritance.</p>
            
            <div class="implementation">
                <h4>ðŸ”§ Implementation</h4>
                <pre><code>// RBAC System Implementation
class RBACManager {
    constructor(database) {
        this.db = database;
    }

    // Define role hierarchy and permissions
    async initializeRoles() {
        const roles = [
            {
                name: 'admin',
                permissions: ['*'], // All permissions
                inherits: []
            },
            {
                name: 'manager',
                permissions: ['read:all', 'write:own', 'delete:own'],
                inherits: ['user']
            },
            {
                name: 'user',
                permissions: ['read:own', 'write:own'],
                inherits: []
            },
            {
                name: 'viewer',
                permissions: ['read:own'],
                inherits: []
            }
        ];

        for (const role of roles) {
            await this.db.roles.upsert({ name: role.name }, role);
        }
    }

    // Assign role to user
    async assignRole(userId, roleName) {
        const role = await this.db.roles.findOne({ name: roleName });
        if (!role) throw new Error('Role not found');

        await this.db.userRoles.upsert(
            { user_id: userId },
            { user_id: userId, role_name: roleName, assigned_at: new Date() }
        );
    }

    // Get effective permissions for user
    async getUserPermissions(userId) {
        const userRole = await this.db.userRoles.findOne({ user_id: userId });
        if (!userRole) return [];

        return this.resolveRolePermissions(userRole.role_name);
    }

    // Resolve role permissions with inheritance
    async resolveRolePermissions(roleName, visited = new Set()) {
        if (visited.has(roleName)) {
            throw new Error(`Circular role inheritance detected: ${roleName}`);
        }
        visited.add(roleName);

        const role = await this.db.roles.findOne({ name: roleName });
        if (!role) return [];

        let permissions = [...role.permissions];

        // Inherit permissions from parent roles
        for (const parentRole of role.inherits || []) {
            const parentPermissions = await this.resolveRolePermissions(parentRole, visited);
            permissions = permissions.concat(parentPermissions);
        }

        return [...new Set(permissions)]; // Remove duplicates
    }

    // Check if user has specific permission
    async hasPermission(userId, permission, resource = null) {
        const userPermissions = await this.getUserPermissions(userId);
        
        // Check for wildcard permission
        if (userPermissions.includes('*')) return true;
        
        // Check for exact permission match
        if (userPermissions.includes(permission)) return true;
        
        // Check for resource-specific permissions
        if (resource) {
            const resourcePermission = `${permission}:${resource}`;
            if (userPermissions.includes(resourcePermission)) return true;
        }

        return false;
    }

    // Middleware for route protection
    requirePermission(permission) {
        return async (req, res, next) => {
            const userId = req.user?.id;
            if (!userId) {
                return res.status(401).json({ error: 'Authentication required' });
            }

            const hasAccess = await this.hasPermission(userId, permission);
            if (!hasAccess) {
                return res.status(403).json({ 
                    error: 'Insufficient permissions',
                    required: permission 
                });
            }

            next();
        };
    }
}</code></pre>
            </div>

            <div class="validation">
                <h4>âœ… Validation</h4>
                <ul>
                    <li>Test permission inheritance works correctly</li>
                    <li>Verify users cannot access unauthorized resources</li>
                    <li>Check role assignment and revocation</li>
                    <li>Test circular inheritance detection</li>
                </ul>
            </div>

            <div class="best-practices">
                <h4>ðŸ“‹ Best Practices</h4>
                <ul>
                    <li>Follow principle of least privilege</li>
                    <li>Use descriptive permission names</li>
                    <li>Implement role hierarchies carefully</li>
                    <li>Regular access reviews and cleanup</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Control 2.2 -->
    <div class="control-card">
        <div class="control-header">
            <h3 class="control-title">2.2 Attribute-Based Access Control (ABAC)</h3>
            <div class="control-badges">
                <span class="badge priority-high">High</span>
                <span class="badge difficulty-high">High</span>
            </div>
        </div>
        
        <div class="control-content">
            <p class="control-description">Implement fine-grained attribute-based access control using policies that evaluate user, resource, and environmental attributes.</p>
            
            <div class="implementation">
                <h4>ðŸ”§ Implementation</h4>
                <pre><code>// ABAC Policy Engine
class ABACEngine {
    constructor() {
        this.policies = new Map();
    }

    // Define ABAC policy
    addPolicy(name, policy) {
        this.policies.set(name, {
            ...policy,
            evaluate: this.compilePolicy(policy.rules)
        });
    }

    // Compile policy rules into executable function
    compilePolicy(rules) {
        return (context) => {
            return rules.every(rule => this.evaluateRule(rule, context));
        };
    }

    // Evaluate individual rule
    evaluateRule(rule, context) {
        const { attribute, operator, value } = rule;
        const contextValue = this.getAttributeValue(attribute, context);

        switch (operator) {
            case 'equals':
                return contextValue === value;
            case 'in':
                return Array.isArray(value) && value.includes(contextValue);
            case 'gt':
                return contextValue > value;
            case 'lt':
                return contextValue < value;
            case 'contains':
                return Array.isArray(contextValue) && contextValue.includes(value);
            case 'matches':
                return new RegExp(value).test(contextValue);
            default:
                throw new Error(`Unknown operator: ${operator}`);
        }
    }

    // Get attribute value from context
    getAttributeValue(attribute, context) {
        const parts = attribute.split('.');
        let value = context;
        
        for (const part of parts) {
            value = value?.[part];
        }
        
        return value;
    }

    // Evaluate access request
    async authorize(context) {
        const results = [];
        
        for (const [name, policy] of this.policies) {
            const result = {
                policy: name,
                effect: policy.effect,
                decision: policy.evaluate(context)
            };
            results.push(result);
        }

        // Policy combination logic
        return this.combineDecisions(results);
    }

    // Combine policy decisions
    combineDecisions(results) {
        // Deny overrides - any explicit deny blocks access
        const denyResults = results.filter(r => r.effect === 'deny' && r.decision);
        if (denyResults.length > 0) {
            return { decision: 'deny', reason: 'Explicit deny policy matched' };
        }

        // Permit if any allow policy matches
        const permitResults = results.filter(r => r.effect === 'allow' && r.decision);
        if (permitResults.length > 0) {
            return { decision: 'allow', reason: 'Allow policy matched' };
        }

        return { decision: 'deny', reason: 'No matching allow policy' };
    }
}

// Example usage and policy definitions
const abac = new ABACEngine();

// Policy: Users can read their own data
abac.addPolicy('read-own-data', {
    effect: 'allow',
    rules: [
        { attribute: 'action', operator: 'equals', value: 'read' },
        { attribute: 'user.id', operator: 'equals', value: 'resource.owner_id' }
    ]
});

// Policy: Managers can access team data during business hours
abac.addPolicy('manager-team-access', {
    effect: 'allow',
    rules: [
        { attribute: 'user.role', operator: 'equals', value: 'manager' },
        { attribute: 'resource.team', operator: 'equals', value: 'user.team' },
        { attribute: 'environment.time', operator: 'gt', value: '09:00' },
        { attribute: 'environment.time', operator: 'lt', value: '17:00' }
    ]
});

// Policy: Deny access from untrusted networks
abac.addPolicy('network-restriction', {
    effect: 'deny',
    rules: [
        { attribute: 'environment.ip', operator: 'matches', value: '^192\\.168\\.' }
    ]
});

// Express middleware
function abacMiddleware(action, resourceLoader) {
    return async (req, res, next) => {
        const resource = await resourceLoader(req);
        
        const context = {
            user: req.user,
            action: action,
            resource: resource,
            environment: {
                ip: req.ip,
                time: new Date().getHours(),
                userAgent: req.get('User-Agent')
            }
        };

        const decision = await abac.authorize(context);
        
        if (decision.decision === 'deny') {
            return res.status(403).json({ 
                error: 'Access denied', 
                reason: decision.reason 
            });
        }

        next();
    };
}</code></pre>
            </div>
        </div>
    </div>

    <!-- Additional authorization controls 2.3-2.10 would continue here -->
    
</section>